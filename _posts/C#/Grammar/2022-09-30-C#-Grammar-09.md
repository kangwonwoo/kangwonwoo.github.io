---
title:      C# Grammar#09 | Anonymous Method, Delegate, Lambda
date:       "2022-09-30"
categories: ["C#", "01.Structure"]
tags:       ["C#", "Grammar", "Unity"]
# pin:        true
---

# Anonymous Method(무명 메서드)
- 익명 메소드란 이름이 없는 메소드를 말한다. 
- 익명 메소드는 ```delegate``` 키워드를 이용하여 선언한다. 
```c#
대리자 인스턴스 = delegate(매개변수 목록)
               {
                   // 실행하고자 하는 코드
               };
```
- 익명 메소드는 자신을 참조할 대리자의 형식과 동일한 형식으로 선언되어야 한다.  
```c#
delegate int Calculate(int a, int b);

public static void Main(){
    Calculate calc;
    calc = delegate(int a, int b){
               return a + b;
           };
}
```
- 반환 형식을 ```int```로 선언했다면 익명 메소드도 ```int``` 형식의 결과를 반환해야 하며, 대리자에서 ```int``` 형식의 매개 변수 2개를 받도록 선언했다면 익명 메소드도 역시 동일하게 매개 변수를 받도록 구현해야 한다.
- 익명 메소드는 아주 유용하게 사용된다. 대리자가 참조할 메소드를 넘겨야 할 시기에 이 메소드가 두 번 다시 사용할 일이 없다고 판단되면 그 때가 익명 메소드를 사용할 타이밍이다.

# Delegate(대리자)
- 함수를 가리키는 변수라고 생각하면 쉽다.
- 어떠한 기능을 목록에 추가해놓으면 여러분들의 기능을 대신 수행시켜준다. 
- **delegate 를 사용하는 이유** 
```c#
static void ButtonPressed() // 버튼이 눌렸을 때 실행
{
    // 버틀이 눌렸을 때 실행할 여러가지 함수들 나열 및 실행
}
```
- 버튼이 눌리면 아바타에 옷을 입힌다 👉 무기를 들게 한다. 👉 랜덤 메세지를 출력한다. 이런 과정들이 순차적으로 실행되게 하고 싶다면 버튼 눌리는 함수 내부에 각각의 기능들을 함수로 직접 실행시키면 되겠다.
  - 즉 ButtonPressed() 함수 내부에서 직접 여러 함수들에게 인수를 넘겨 호출하는 방식이다. 
  - 그러나 이런 구현 방식의 문제점은 ButtonPressed() 함수 내부에서 함수들을 실행시키면서 일일이 매개 변수에게 인수를 넘겨야 하기 때문에 개발자가 실수를 할 확률도 커지고, 예를 들어 게임 로직 함수와 UI 관련 함수가 섞여 있으니 설계적으로 보기도 좋지 않은 등등.. 여러모로 아쉬운 부분들이 있다. 
  - 유니티의 경우 ButtonPressed() 이런 버튼 클릭시 실행시킬 함수는 유니티에서 제공되는 이벤트 함수이기 때문에 함수 내부에다가 버튼 클릭시 내가 원하는 함수들 직접 추가할 수도 없다. 
  - 유니티 제공 시스템 함수라서 수정 불가능.

- 만약 ButtonPressed() 함수에 위 과정의 각각의 기능을 실행하는 함수들 자체를 인자로 넘기고 ButtonPressed() 내에선 **이게 어떤 함수인지 몰라도 되며 그저 실행만 시키면 될 뿐이라면 위와 같은 문제들이 해결될 것이다.** 
  - 마치 실행 해야할 함수 포인터들만 ButtonPressed()에게 인자로 넘겨주고 ‘대신 실행 부탁드려요~’ 하는 것과 같다. 
  - **일일이 실행될 함수들을 나열하여 직접 호출하고 그 함수들에게 인자 직접 명시하여 넘기고.. 그런 과정이 필요가 없다.** 
  - 델리게이트 딱 하나만 실행하면 되기 때문에! (등록은 다른데서 필요할 때마다 해두고)

# Lambda(람다식)
- 람다식은 간단하게 무명 메서드를 단순화 하는데 사용한 식이다.
- 람다식은 메서드는 크게 반환형, 매개변수, 내부 식으로 구성되어 있는데, 이 형식으로 무명 메서드를 단순한
계산식으로 표현한 것이다. 
- 람다식은 매개변수의 타입까지도 생략이 가능하다.
- 똑똑한 컴파일러가 좌항의 델리게이트 타입을 참고해서 타입을 유추하는 것이다.

---

# 참고 사이트
- [Developer's Note](https://euncero.tistory.com/724)
- [nomad-programmer](https://nomad-programmer.tistory.com/193)
- [공부하는 식빵맘](https://ansohxxn.github.io/c%20sharp/ch9-4/)